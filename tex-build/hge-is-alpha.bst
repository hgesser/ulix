%% =====================================================================
%% WARNING: Do NOT edit this file.  It was produced automatically by
%% Nelson H. F. Beebe <beebe@plot79.math.utah.edu>
%% from file://plot79.math.utah.edu/u/sy/beebe/tex/bib/merge/xbtxbst.doc 
%% on Wed May 15 10:36:04 MDT 1996.
%% =====================================================================
%%%=====================================================================
%%% @BibTeX-style-file{
%%%     author          = "Nelson H. F. Beebe",
%%%     version         = "2.03",
%%%     date            = "15 May 1996",
%%%     time            = "10:35:51 MDT",
%%%     filename        = "is-alpha.bst",
%%%     address         = "Center for Scientific Computing
%%%                        Department of Mathematics
%%%                        University of Utah
%%%                        Salt Lake City, UT 84112
%%%                        USA",
%%%     telephone       = "+1 801 581 5254",
%%%     FAX             = "+1 801 581 4148",
%%%     URL             = "http://www.math.utah.edu/~beebe",
%%%     checksum        = "49675 2020 5086 41225",
%%%     email           = "beebe@math.utah.edu (Internet)",
%%%     codetable       = "ISO/ASCII",
%%%     keywords        = "BibTeX, style, bibliography",
%%%     supported       = "yes",
%%%     docstring       = "This file is a modification of the standard
%%%                        BibTeX btxbst.doc file, or is a .bst file
%%%                        derived from that modification.  It contains
%%%                        optional added support for CODEN, ISBN, ISSN,
%%%                        LCCN, and PRICE fields, extended PAGES
%%%                        fields, the PERIODICAL entry, and extended
%%%                        citation label suffixing.
%%%
%%%                        In addition, date formatting supports a day
%%%                        keyword, so that bibliography entries can be
%%%                        written with
%%%
%%%                            day   = {23},
%%%                            month = aug,
%%%
%%%                        instead of the language-dependent awkward
%%%                        forms required by the standard styles
%%%
%%%                            month = {23~} # aug,
%%%                            month = aug # {~23},
%%%
%%%                        These older forms are, of course, still
%%%                        handled correctly.
%%%
%%%                        The UNIX C preprocessor can be used to
%%%                        extract the standard styles, as follows:
%%%
%%%                            cpp -P -DPLAIN xbtxbst.doc >plain.bst
%%%                            cpp -P -DUNSRT xbtxbst.doc >unsrt.bst
%%%                            cpp -P -DALPHA xbtxbst.doc >alpha.bst
%%%                            cpp -P -DABBRV xbtxbst.doc >abbrv.bst
%%%
%%%                        To obtain correct file header checksums, pipe
%%%                        the output through the checksum program, e.g.
%%%
%%%                            cpp -P -DPLAIN xbtxbst.doc | checksum >plain.bst
%%%
%%%                        The accompanying UNIX Makefile automates this
%%%                        job, and provides some extra leading comments
%%%                        in the generated style files warning the user
%%%                        not to modify them.
%%%
%%%                        Additional optional definitions are recognized
%%%                        to provide extensions to the standard styles:
%%%
%%%                            -D_CODEN for CODEN output
%%%
%%%                            -D_ISBN for ISBN output
%%%
%%%                            -D_ISSN for ISSN output
%%%
%%%                            -D_LCCN for LCCN output
%%%
%%%                            -D_PRICE for price output,
%%%
%%%                            -D_BOOKPAGES for book, techreport, manual,
%%%                            and thesis pages output.
%%%
%%%                            -D_URL to get World-Wide Web Uniform
%%%                            Resource Locator (URL) output.
%%%
%%%                            -D_NUMERIC_SUFFIXES to get numeric
%%%                            label suffixes -1, -2, ..., -26, instead of
%%%                            letters a, b, ..., z, so as to correctly
%%%                            handle alpha-style bibliographies with more
%%%                            than 26 entries for a single author in one
%%%                            year.  Change letter suffix code to switch
%%%                            to numeric suffixes if more than 26 letters
%%%                            are used, so that no matter which scheme is
%%%                            selected, correct output will always be
%%%                            obtained.
%%%
%%%                        The CODEN, ISBN, ISSN, LCCN, PRICE, and URL
%%%                        values are wrapped inside macros \showCODEN{}
%%%                        etc. that the user can provide alternate
%%%                        definitions of to change the formatting, or
%%%                        to suppress their output altogether.  That
%%%                        way, output identical to that of the four
%%%                        standard BibTeX style files can be obtained
%%%                        with these extended files, if these macros
%%%                        are defined to expand to empty strings.
%%%
%%%                        URL handling is slightly more complex,
%%%                        because URLs can contain characters which TeX
%%%                        must handle in verbatim mode in a typewriter
%%%                        font, and such text cannot readily appear
%%%                        inside nested macro arguments.  Consequently,
%%%                        URLs are formatted in the .bbl file like
%%%                        this:
%%%                            \ifshowURL {\showURL \path|...|} \fi
%%%                        where \showURL takes no argument, and
%%%                        normally expands to the 4-character string
%%%                        URL<space>.  The grouping braces ensure that
%%%                        any font changes made by \showURL remain
%%%                        localized.  Vertical bar is chosen as the
%%%                        verbatim path delimiter, because it cannot
%%%                        appear in URLs.  The other prohibited ISO
%%%                        Latin 1 characters are the non-printing
%%%                        control characters 0..31, plus those in the
%%%                        range 128..255, plus the ten special
%%%                        characters
%%%
%%%                            { } [ ] \ ^ ~ < > `
%%%
%%%                        See Internet RFC 1630 (June 1994) for more
%%%                        details.  (Backquote is not even mentioned
%%%                        there.)
%%%
%%%                        As an example of font changes, in LaTeX 2e
%%%                        you might define
%%%                            \newcommand{\showURL}{URL
%%%                                \let \oldtt = \tt
%%%                                \renewcommand{\tt}{\oldtt \itshape}}
%%%                        to get URLs set in a typewriter italic font.
%%%
%%%                        If desired, a sed script can be used to
%%%                        eliminate non-essential comments (this
%%%                        reduces the file size by 2/3); a command
%%%                        filter step like
%%%                                sed -e '/^%$/d' -e '/^%[^%].*$/d'
%%%                        will accomplish that job.
%%%
%%%                        The checksum field above contains a CRC-16
%%%                        checksum as the first value, followed by the
%%%                        equivalent of the standard UNIX wc (word
%%%                        count) utility output of lines, words, and
%%%                        characters.  This is produced by Robert
%%%                        Solovay's checksum utility."
%%%     }
%%% ====================================================================
%%% Revision history (reverse time order):
%%%
%%% 2.03 [15-May-1996]
%%%      Add CODEN support, ISBN and ISSN output for Article entries,
%%%      and ISBN output for TechReport entries (yes, these sometimes
%%%      do have ISBNs).
%%%
%%%      Add wrapper macros \showXYZ{} (XYZ = CODEN, ISBN, ISSN, LCCN,
%%%      PRICE, and URL) defined inside the thebibliography environment
%%%      to expand to XYZ (except for PRICE) and their arguments,
%%%      PROVIDED they are not already defined.  That way, the user can
%%%      provide alternate definitions outside the thebibliography
%%%      environment, for example, to suppress particular ones, or
%%%      to alter the font used.
%%%
%%%      Substantially revise leading comments to better document the
%%%      extensions.
%%%
%%% 2.02 [01-Apr-1996]
%%%	 Add day keyword support with new code in format.date function.
%%%	 Oren Patashnik will include this new keyword in standard styles
%%%	 in BibTeX 1.0.
%%%
%%%	 Add new function collapse.pagerange, and use it to collapse
%%%	 page ranges with identical initial and final numbers to a
%%%	 single number, so that bibliography files can distinguish
%%%	 between one-page documents, and documents missing final page
%%%	 numbers.
%%%
%%% 2.01 [25-Oct-1994]
%%%	 Add URL output support.
%%%
%%% 2.00 [12-Oct-1994]
%%%	 Add support for pages in theses and manuals, treating them
%%%	 like Book and InBook pages.
%%%
%%%	 Correct ISSN support: a typo caused output of ISBN instead of
%%%	 ISSN.
%%%
%%%	 Wherever ISBNs are output, also output an ISSN, if one
%%%	 exists, and vice versa.  The reason is that some periodicals
%%%	 (e.g. The X Resource, published by O'Reilly and Associates)
%%%	 have both ISSN and ISBN numbers, and can be purchased either
%%%	 as journal subscriptions, or as single volumes.
%%%
%%%	 For InProceedings and Proceedings output, issue a warning for
%%%	 a missing publisher: even though that field is optional, a
%%%	 bibliographic reference without it is incomplete.
%%%
%%%	 Remove harmless, but unneeded, single horizontal space before
%%%	 price output added with version 1.03.
%%%
%%%	 Change Proceedings and InProceedings to treat address values
%%%	 as publisher addresses, as they are with every other document
%%%	 type, rather than as conference addresses, which belong in
%%%	 the title field (that is how major libraries, including OCLC
%%%	 and Library of Congress, with nearly 60M holdings, represent
%%%	 them).  The need for this change has been discussed with
%%%	 BibTeX's author, Oren Patashnik, and there is a good
%%%	 possibility that BibTeX 1.0 will contain the change
%%%	 implemented here.  This is an INCOMPATIBLE change that will
%%%	 produce different .bbl file formatting.  However, the TUG and
%%%	 BibNet bibliography projects have consistently used address
%%%	 to me publisher/organization/institution address, and so
%%%	 already conform to the new practice.
%%%
%%% 1.05 [30-May-1994]
%%%	 Add NUMERIC_SUFFIXES support.
%%%
%%%	 Change all preprocessor statements to put else and endif
%%%	 labels inside C-style comments to conform to 1989 ISO/ANSI C
%%%	 Standard.
%%%
%%% 1.04 [11-Nov-1993]
%%%	 Add underscore prefix to new processor symbols to prevent
%%%	 substitution in comments
%%%
%%% 1.03 [11-Oct-1993]
%%%	 Add support for LCCN (Library of Congress Catalog Number)
%%%	 and price fields, and make ISBN, ISSN, LCCN, and price
%%%	 selectable by preprocessor conditionals.
%%%
%%% 1.02 [12-Sep-1991]
%%%      Merge in Barbara N. Beeton's suggestion for hyphen-less
%%%      line breaks around volume(number):page.
%%%
%%% 1.01 [10-Sep-1991]
%%%      Update file comment header and use Solovay checksum program.
%%%
%%% 1.00 [17-Oct-1990]
%%%      Original version merging hand-edits of is-xxx.bst files into
%%%      this master file, xbtxbst.doc.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% BibTeX `plain' family
%%       version 0.99b for BibTeX versions 0.99a or later, LaTeX version 2.09.
%%       Copyright (C) 1985, all rights reserved.
%%       Copying of this file is authorized only if either
%%       (1) you make absolutely no changes to your copy, including name, or
%%       (2) if you do make changes, you name it something other than
%%       btxbst.doc, plain.bst, unsrt.bst, alpha.bst, and abbrv.bst.
%%       This restriction helps ensure that all standard styles are identical.
%%       The file btxbst.doc has the documentation for this style.















ENTRY
  { address
    author
    booktitle
    chapter

    coden

    day
    edition
    editor
    howpublished
    institution

    isbn


    issn

    journal
    key

    lccn

    month
    note
    number
    organization
    pages

    price

    publisher
    school
    series
    title
    type

    URL

    volume
    year
  }
  {}


  { label extra.label sort.label }




INTEGERS { output.state before.all mid.sentence after.sentence after.block }

FUNCTION {init.state.consts}
{ #0 'before.all :=
  #1 'mid.sentence :=
  #2 'after.sentence :=
  #3 'after.block :=
}


STRINGS { b e new.pages original.t s t }

FUNCTION {output.nonnull}
{ 's :=
  output.state mid.sentence =
    { ", " * write$ }
    { output.state after.block =
        { add.period$ write$
          newline$
          "\newblock " write$
        }
        { output.state before.all =
            'write$
            { add.period$ " " * write$ }
          if$
        }
      if$
      mid.sentence 'output.state :=
    }
  if$
  s
}

FUNCTION {output}
{ duplicate$ empty$
    'pop$
    'output.nonnull
  if$
}

FUNCTION {output.check}
{ 't :=
  duplicate$ empty$
    { pop$ "empty " t * " in " * cite$ * warning$ }
    'output.nonnull
  if$
}

FUNCTION {output.bibitem}
{ newline$

  "\bibitem[" write$
  label write$
  "]{" write$

  cite$ write$
  "}" write$
  newline$
  ""
  before.all 'output.state :=
}


FUNCTION {fin.entry}
{ add.period$
  write$
  newline$
}

FUNCTION {new.block}
{ output.state before.all =
    'skip$
    { after.block 'output.state := }
  if$
}

FUNCTION {new.sentence}
{ output.state after.block =
    'skip$
    { output.state before.all =
        'skip$
        { after.sentence 'output.state := }
      if$
    }
  if$
}


FUNCTION {not}
{   { #0 }
    { #1 }
  if$
}

FUNCTION {and}
{   'skip$
    { pop$ #0 }
  if$
}

FUNCTION {or}
{   { pop$ #1 }
    'skip$
  if$
}


FUNCTION {new.block.checka}
{ empty$
    'skip$
    'new.block
  if$
}

FUNCTION {new.block.checkb}
{ empty$
  swap$ empty$
  and
    'skip$
    'new.block
  if$
}


FUNCTION {new.sentence.checka}
{ empty$
    'skip$
    'new.sentence
  if$
}

FUNCTION {new.sentence.checkb}
{ empty$
  swap$ empty$
  and
    'skip$
    'new.sentence
  if$
}


FUNCTION {field.or.null}
{ duplicate$ empty$
    { pop$ "" }
    'skip$
  if$
}

FUNCTION {emphasize}
{ duplicate$ empty$
    { pop$ "" }
    { "{\em " swap$ * "}" * }
  if$
}

INTEGERS { nameptr namesleft numnames }

FUNCTION {format.names}
{ 's :=
  #1 'nameptr :=
  s num.names$ 'numnames :=
  numnames 'namesleft :=
    { namesleft #0 > }

    { s nameptr "{ff~}{vv~}{ll}{, jj}" format.name$ 't :=

      nameptr #1 >
        { namesleft #1 >
            { ", " * t * }
            { numnames #2 >
                { "," * }
                'skip$
              if$
              t "others" =
                { " et~al." * }
                { " and " * t * }
              if$
            }
          if$
        }
        't
      if$
      nameptr #1 + 'nameptr :=
      namesleft #1 - 'namesleft :=
    }
  while$
}

FUNCTION {format.authors}
{ author empty$
    { "" }
    { author format.names }
  if$
}


FUNCTION {format.coden}
{ coden empty$
    { "" }
    { new.block "\showCODEN{" coden * "}" *}
  if$
}


FUNCTION {format.editors}
{ editor empty$
    { "" }
    { editor format.names
      editor num.names$ #1 >
        { ", editors" * }
        { ", editor" * }
      if$
    }
  if$
}


FUNCTION {format.isbn}
{ isbn empty$
    { "" }
    { new.block "\showISBN{" isbn * "}" *}
  if$
}



FUNCTION {format.issn}
{ issn empty$
    { "" }
    { new.block "\showISSN{" issn * "}" *}
  if$
}



FUNCTION {format.lccn}
{ lccn empty$
    { "" }
    { new.block "\showLCCN{" lccn * "}" *}
  if$
}



FUNCTION {format.price}
{ price empty$
    { "" }
    { new.block "\showPRICE{" price * "}" *}
  if$
}



FUNCTION {format.url}
{ url empty$
    { "" }
%%%    { new.block "\ifshowURL {\showURL \path|" url * "|}\fi" *}
%%%    { new.block "\ifshowURL {\showURL \sloppy\url{" url * "}}\fi" *}
%%%    { new.block "\ifshowURL {\showURL \url{" url * "}}\fi" *}
    { new.block "\ifshowURL {\showURL \myQ{" url * "}}\fi" *}
  if$
}




FUNCTION {format.title}
{ title empty$
    { "" }

    { title }

  if$
}



FUNCTION {collapse.pagerange}
{ 't :=				% save input page range string
  t 'original.t :=		% save original page range
  "" 'b :=			% beginning page number
  "" 'e :=			% ending page number
    { t empty$ not }		% while-loop Boolean condition
    {				% while-loop body
      t #1 #2 substring$ "--" =	% have we found the en-dash?
	{
	   t #3 global.max$ substring$ 'e :=	% yes, save ending page number
	   "" 't := 		% and set t to empty string to terminate loop
	}
	{
	   b t #1 #1 substring$ * 'b := % no, just accumulate this character
	   t #2 global.max$ substring$ 't := % and set t to the remaining string
	}
      if$
    }
  while$			% on exit, t has ending page number string
  e b =				% are beginning and ending numbers the same?
    { b	}			% yes, return the beginning page number string
    { original.t }		% no, return the original page number string
  if$
}


FUNCTION {n.dashify}
{ 't :=
  ""
    { t empty$ not }
    { t #1 #1 substring$ "-" =
        { t #1 #2 substring$ "--" = not
            { "--" *
              t #2 global.max$ substring$ 't :=
            }
            {   { t #1 #1 substring$ "-" = }
                { "-" *
                  t #2 global.max$ substring$ 't :=
                }
              while$
            }
          if$
        }
        { t #1 #1 substring$ *
          t #2 global.max$ substring$ 't :=
        }
      if$
    }
  while$
}


FUNCTION {format.date}
{ year empty$
    { month empty$
        {
	  day empty$
	    { "" }
	    { "there's a day but no month or year in " cite$ * warning$ }
	  if$
	}
        { "there's a month but no year in " cite$ * warning$
          month
	  day empty$
            { }
	    { " " * day * }
          if$
        }
      if$
    }
    { month empty$
	{
	  day empty$
	    { year }
	    { "there's a day and year but no month in " cite$ * warning$ }
	  if$
	}
        {
          month " " *
	  day empty$
            { }
	    { day * ", " * }
          if$
          year *
        }
      if$
    }
  if$
}


FUNCTION {format.btitle}
{ title emphasize
}


FUNCTION {tie.or.space.connect}
{ duplicate$ text.length$ #3 <
    { "~" }
    { " " }
  if$
  swap$ * *
}


FUNCTION {either.or.check}
{ empty$
    'pop$
    { "can't use both " swap$ * " fields in " * cite$ * warning$ }
  if$
}


FUNCTION {format.bvolume}
{ volume empty$
    { "" }
    { "volume" volume tie.or.space.connect
      series empty$
        'skip$
        { " of " * series emphasize * }
      if$
      "volume and number" number either.or.check
    }
  if$
}


FUNCTION {format.number.series}
{ volume empty$
    { number empty$
        { series field.or.null }
        { output.state mid.sentence =
            { "number" }
            { "Number" }
          if$
          number tie.or.space.connect
          series empty$
            { "there's a number but no series in " cite$ * warning$ }
            { " in " * series * }
          if$
        }
      if$
    }
    { "" }
  if$
}


FUNCTION {format.edition}
{ edition empty$
    { "" }
    { output.state mid.sentence =
        { edition "l" change.case$ " edition" * }
        { edition "t" change.case$ " edition" * }
      if$
    }
  if$
}


INTEGERS { multiresult }

FUNCTION {multi.page.check}
{ 't :=
  #0 'multiresult :=
    { multiresult not
      t empty$ not
      and
    }
    { t #1 #1 substring$
      duplicate$ "-" =
      swap$ duplicate$ "," =
      swap$ "+" =
      or or
        { #1 'multiresult := }
        { t #2 global.max$ substring$ 't := }
      if$
    }
  while$
  multiresult
}


FUNCTION {format.book.pages}
{ pages empty$
    { "" }
    { new.block pages " pp." * }
  if$
}



FUNCTION {format.pages}
{ pages empty$
    { "" }
    {
      pages multi.page.check
        { pages collapse.pagerange 'new.pages := }
	{ pages 'new.pages := }
      if$
      new.pages multi.page.check
        { "pages" new.pages n.dashify tie.or.space.connect }
        { "page" new.pages tie.or.space.connect }
      if$
    }
  if$
}


FUNCTION {format.vol.num.pages}
{ volume field.or.null
  number empty$
    'skip$
    { "\penalty0 (" number * ")" * *
      volume empty$
        { "there's a number but no volume in " cite$ * warning$ }
        'skip$
      if$
    }
  if$
  pages empty$
    'skip$
    { duplicate$ empty$
        { pop$ format.pages }
        { ":\penalty0 " * pages collapse.pagerange n.dashify * }
      if$
    }
  if$
}



FUNCTION {format.chapter.pages}
{ chapter empty$
    'format.pages
    { type empty$
        { "chapter" }
        { type "l" change.case$ }
      if$
      chapter tie.or.space.connect
      pages empty$
        'skip$
        { ", " * format.pages * }
      if$
    }
  if$
}


FUNCTION {format.in.ed.booktitle}
{ booktitle empty$
    { "" }
    { editor empty$
        { "In " booktitle emphasize * }
        { "In " format.editors * ", " * booktitle emphasize * }
      if$
    }
  if$
}


FUNCTION {empty.misc.check}
{ author empty$ title empty$ howpublished empty$
  month empty$ year empty$ note empty$
  and and and and and

  key empty$ not and

    { "all relevant fields are empty in " cite$ * warning$ }
    'skip$
  if$
}


FUNCTION {format.thesis.type}
{ type empty$
    'skip$
    { pop$
      type "t" change.case$
    }
  if$
}


FUNCTION {format.tr.number}
{ type empty$
    { "Technical Report" }
    'type
  if$
  number empty$
    { "t" change.case$ }
    { number tie.or.space.connect }
  if$
}


FUNCTION {format.article.crossref}
{ key empty$
    { journal empty$
        { "need key or journal for " cite$ * " to crossref " * crossref *
          warning$
          ""
        }
        { "In {\em " journal * "\/}" * }
      if$
    }
    { "In " key * }
  if$
  " \cite{" * crossref * "}" *
}


FUNCTION {format.crossref.editor}
{ editor #1 "{vv~}{ll}" format.name$
  editor num.names$ duplicate$
  #2 >
    { pop$ " et~al." * }
    { #2 <
        'skip$
        { editor #2 "{ff }{vv }{ll}{ jj}" format.name$ "others" =
            { " et~al." * }
            { " and " * editor #2 "{vv~}{ll}" format.name$ * }
          if$
        }
      if$
    }
  if$
}


FUNCTION {format.book.crossref}
{ volume empty$
    { "empty volume in " cite$ * "'s crossref of " * crossref * warning$
      "In "
    }
    { "Volume" volume tie.or.space.connect
      " of " *
    }
  if$
  editor empty$
  editor field.or.null author field.or.null =
  or
    { key empty$
        { series empty$
            { "need editor, key, or series for " cite$ * " to crossref " *
              crossref * warning$
              "" *
            }
            { "{\em " * series * "\/}" * }
          if$
        }
        { key * }
      if$
    }
    { format.crossref.editor * }
  if$
  " \cite{" * crossref * "}" *
}


FUNCTION {format.incoll.inproc.crossref}
{ editor empty$
  editor field.or.null author field.or.null =
  or
    { key empty$
        { booktitle empty$
            { "need editor, key, or booktitle for " cite$ * " to crossref " *
              crossref * warning$
              ""
            }
            { "In {\em " booktitle * "\/}" * }
          if$
        }
        { "In " key * }
      if$
    }
    { "In " format.crossref.editor * }
  if$
  " \cite{" * crossref * "}" *
}


FUNCTION {article}
{ output.bibitem
  format.authors "author" output.check
  new.block
  format.title "title" output.check
  new.block
  crossref missing$
    { journal emphasize "journal" output.check
      format.vol.num.pages output
      format.date "year" output.check
    }
    { format.article.crossref output.nonnull
      format.pages output
    }
  if$

  format.coden output


  format.isbn output


  format.issn output


  format.url output

  new.block
  note output
  fin.entry
}

FUNCTION {book}
{ output.bibitem
  author empty$
    { format.editors "author and editor" output.check }
    { format.authors output.nonnull
      crossref missing$
        { "author and editor" editor either.or.check }
        'skip$
      if$
    }
  if$
  new.block
  format.btitle "title" output.check
  crossref missing$
    { format.bvolume output
      new.block
      format.number.series output
      new.sentence
      publisher "publisher" output.check
      address output
    }
    { new.block
      format.book.crossref output.nonnull
    }
  if$
  format.edition output
  format.date "year" output.check

  format.coden output


  format.isbn output


  format.issn output


  format.book.pages output


  format.lccn output


  format.price output


  format.url output

  new.block
  note output
  fin.entry
}


FUNCTION {booklet}
{ output.bibitem
  format.authors output
  new.block
  format.title "title" output.check
  howpublished address new.block.checkb
  howpublished output
  address output
  format.date output

  format.coden output


  format.isbn output


  format.issn output


  format.book.pages output


  format.lccn output


  format.price output


  format.url output

  new.block
  note output
  fin.entry
}



FUNCTION {inbook}
{ output.bibitem
  author empty$
    { format.editors "author and editor" output.check }
    { format.authors output.nonnull
      crossref missing$
        { "author and editor" editor either.or.check }
        'skip$
      if$
    }
  if$
  new.block
  format.btitle "title" output.check
  crossref missing$
    { format.bvolume output
      format.chapter.pages "chapter and pages" output.check
      new.block
      format.number.series output
      new.sentence
      publisher "publisher" output.check
      address output
    }
    { format.chapter.pages "chapter and pages" output.check
      new.block
      format.book.crossref output.nonnull
    }
  if$
  format.edition output
  format.date "year" output.check

  format.coden output


  format.isbn output


  format.issn output


  format.lccn output


  format.price output


  format.url output

  new.block
  note output
  fin.entry
}


FUNCTION {incollection}
{ output.bibitem
  format.authors "author" output.check
  new.block
  format.title "title" output.check
  new.block
  crossref missing$
    { format.in.ed.booktitle "booktitle" output.check
      format.bvolume output
      format.number.series output
      format.chapter.pages output
      new.sentence
      publisher "publisher" output.check
      address output
      format.edition output
      format.date "year" output.check
    }
    { format.incoll.inproc.crossref output.nonnull
      format.chapter.pages output
    }
  if$

  format.coden output


  format.isbn output


  format.issn output


  format.lccn output


  format.price output


  format.url output

  new.block
  note output
  fin.entry
}


FUNCTION {inproceedings}
{ output.bibitem
  format.authors "author" output.check
  new.block
  format.title "title" output.check
  new.block
  crossref missing$
    { format.in.ed.booktitle "booktitle" output.check
      format.bvolume output
      format.number.series output
      format.pages output
      address empty$
        { organization publisher new.sentence.checkb
          organization output
          publisher "publisher" output.check
          format.date "year" output.check
        }
        { new.sentence
          organization output
          publisher "publisher" output.check
          address output.nonnull
          format.date "year" output.check
        }
      if$
    }
    { format.incoll.inproc.crossref output.nonnull
      format.pages output
    }
  if$

  format.coden output


  format.isbn output


  format.issn output


  format.lccn output


  format.price output


  format.url output

  new.block
  note output
  fin.entry
}


FUNCTION {conference} { inproceedings }


FUNCTION {manual}
{ output.bibitem
  author empty$
    { organization empty$
        'skip$
        { organization output.nonnull
          address output
        }
      if$
    }
    { format.authors output.nonnull }
  if$
  new.block
  format.btitle "title" output.check
  author empty$
    { organization empty$
        { address new.block.checka
          address output
        }
        'skip$
      if$
    }
    { organization address new.block.checkb
      organization output
      address output
    }
  if$
  format.edition output
  format.date output

  format.book.pages output


  format.price output


  format.url output

  new.block
  note output
  fin.entry
}


FUNCTION {mastersthesis}
{ output.bibitem
  format.authors "author" output.check
  new.block
  format.title "title" output.check
  new.block
  "Master's thesis" format.thesis.type output.nonnull
  school "school" output.check
  address output
  format.date "year" output.check

  format.book.pages output


  format.url output

  new.block
  note output
  fin.entry
}



FUNCTION {bachelorsthesis}
{ output.bibitem
  format.authors "author" output.check
  new.block
  format.title "title" output.check
  new.block
  "Bachelor's thesis" format.thesis.type output.nonnull
  school "school" output.check
  address output
  format.date "year" output.check

  format.book.pages output


  format.url output

  new.block
  note output
  fin.entry
}


FUNCTION {misc}
{ output.bibitem
  format.authors output
  title howpublished new.block.checkb
  format.title output
  howpublished new.block.checka
  howpublished output
  format.date output

  format.coden output


  format.isbn output


  format.issn output


  format.price output


  format.url output

  new.block
  note output
  fin.entry
  empty.misc.check
}


FUNCTION {phdthesis}
{ output.bibitem
  format.authors "author" output.check
  new.block
  format.btitle "title" output.check
  new.block
  "PhD thesis" format.thesis.type output.nonnull
  school "school" output.check
  address output
  format.date "year" output.check

  format.book.pages output


  format.url output

  new.block
  note output
  fin.entry
}


FUNCTION {periodical}
{ output.bibitem
  editor empty$
    { organization output }
    { format.editors output.nonnull }
  if$
  new.block
  title emphasize "title" output.check
  format.vol.num.pages output
  format.date output

  format.coden output


  format.isbn output


  format.issn output


  format.price output


  format.url output

  new.sentence
  publisher output
  address output
  howpublished new.block.checka
  howpublished output
  new.block
  note output
  fin.entry
}


FUNCTION {proceedings}
{ output.bibitem
  editor empty$
    { organization output }
    { format.editors output.nonnull }
  if$
  new.block
  format.btitle "title" output.check
  format.bvolume output
  format.number.series output
  address empty$
    { editor empty$
        { publisher new.sentence.checka }
        { organization publisher new.sentence.checkb
          organization output
        }
      if$
      publisher "publisher" output.check %%% <- new check for missing
      format.date "year" output.check
    }
    { new.sentence
      editor empty$
        'skip$
        { organization output }
      if$
      publisher "publisher" output.check
      address output.nonnull
      format.date "year" output.check
    }
  if$

  format.coden output


  format.isbn output


  format.issn output


  format.lccn output


  format.price output


  format.url output

  new.block
  note output
  fin.entry
}


FUNCTION {techreport}
{ output.bibitem
  format.authors "author" output.check
  new.block
  format.title "title" output.check
  new.block
  format.tr.number output.nonnull
  institution "institution" output.check
  address output
  format.date "year" output.check

  format.isbn output		% NB: TechReports occasionally have ISBNs


  format.book.pages output


  format.price output


  format.url output

  new.block
  note output
  fin.entry
}


FUNCTION {unpublished}
{ output.bibitem
  format.authors "author" output.check
  new.block
  format.title "title" output.check
  new.block
  note "note" output.check
  format.date output

  format.url output

  fin.entry
}


FUNCTION {default.type} { misc }




MACRO {jan} {"January"}

MACRO {feb} {"February"}

MACRO {mar} {"March"}

MACRO {apr} {"April"}

MACRO {may} {"May"}

MACRO {jun} {"June"}

MACRO {jul} {"July"}

MACRO {aug} {"August"}

MACRO {sep} {"September"}

MACRO {oct} {"October"}

MACRO {nov} {"November"}

MACRO {dec} {"December"}






MACRO {acmcs} {"ACM Computing Surveys"}

MACRO {acta} {"Acta Informatica"}

MACRO {cacm} {"Communications of the ACM"}

MACRO {ibmjrd} {"IBM Journal of Research and Development"}

MACRO {ibmsj} {"IBM Systems Journal"}

MACRO {ieeese} {"IEEE Transactions on Software Engineering"}

MACRO {ieeetc} {"IEEE Transactions on Computers"}

MACRO {ieeetcad}
 {"IEEE Transactions on Computer-Aided Design of Integrated Circuits"}

MACRO {ipl} {"Information Processing Letters"}

MACRO {jacm} {"Journal of the ACM"}

MACRO {jcss} {"Journal of Computer and System Sciences"}

MACRO {scp} {"Science of Computer Programming"}

MACRO {sicomp} {"SIAM Journal on Computing"}

MACRO {tocs} {"ACM Transactions on Computer Systems"}

MACRO {tods} {"ACM Transactions on Database Systems"}

MACRO {tog} {"ACM Transactions on Graphics"}

MACRO {toms} {"ACM Transactions on Mathematical Software"}

MACRO {toois} {"ACM Transactions on Office Information Systems"}

MACRO {toplas} {"ACM Transactions on Programming Languages and Systems"}

MACRO {tcs} {"Theoretical Computer Science"}




READ




FUNCTION {sortify}
{ purify$
  "l" change.case$
}

INTEGERS { len }

FUNCTION {chop.word}
{ 's :=
  'len :=
  s #1 len substring$ =
    { s len #1 + global.max$ substring$ }
    's
  if$
}






INTEGERS { et.al.char.used }

FUNCTION {initialize.et.al.char.used}
{ #0 'et.al.char.used :=
}

EXECUTE {initialize.et.al.char.used}

FUNCTION {format.lab.names}
{ 's :=
  s num.names$ 'numnames :=
  numnames #1 >
    { numnames #4 >
        { #3 'namesleft := }
        { numnames 'namesleft := }
      if$
      #1 'nameptr :=
      ""
        { namesleft #0 > }
        { nameptr numnames =
            { s nameptr "{ff }{vv }{ll}{ jj}" format.name$ "others" =
                { "{\etalchar{+}}" *
                  #1 'et.al.char.used :=
                }
                { s nameptr "{v{}}{l{}}" format.name$ * }
              if$
            }
            { s nameptr "{v{}}{l{}}" format.name$ * }
          if$
          nameptr #1 + 'nameptr :=
          namesleft #1 - 'namesleft :=
        }
      while$
      numnames #4 >
        { "{\etalchar{+}}" *
          #1 'et.al.char.used :=
        }
        'skip$
      if$
    }
    { s #1 "{v{}}{l{}}" format.name$
      duplicate$ text.length$ #2 <
        { pop$ s #1 "{ll}" format.name$ #3 text.prefix$ }
        'skip$
      if$
    }
  if$
}

FUNCTION {author.key.label}
{ author empty$
    { key empty$

        { cite$ #1 #3 substring$ }

        { key #3 text.prefix$ }
      if$
    }
    { author format.lab.names }
  if$
}

FUNCTION {author.editor.key.label}
{ author empty$
    { editor empty$
        { key empty$

            { cite$ #1 #3 substring$ }

            { key #3 text.prefix$ }
          if$
        }
        { editor format.lab.names }
      if$
    }
    { author format.lab.names }
  if$
}

FUNCTION {author.key.organization.label}
{ author empty$
    { key empty$
        { organization empty$

            { cite$ #1 #3 substring$ }

            { "The " #4 organization chop.word #3 text.prefix$ }
          if$
        }
        { key #3 text.prefix$ }
      if$
    }
    { author format.lab.names }
  if$
}

FUNCTION {editor.key.organization.label}
{ editor empty$
    { key empty$
        { organization empty$

            { cite$ #1 #3 substring$ }

            { "The " #4 organization chop.word #3 text.prefix$ }
          if$
        }
        { key #3 text.prefix$ }
      if$
    }
    { editor format.lab.names }
  if$
}

FUNCTION {calc.label}
{ type$ "book" =
  type$ "inbook" =
  or
    'author.editor.key.label
    { type$ "proceedings" =
        'editor.key.organization.label
        { type$ "manual" =
            'author.key.organization.label
            'author.key.label
          if$
        }
      if$
    }
  if$
  duplicate$
  year field.or.null purify$ #-1 #2 substring$
  *
  'label :=
  year field.or.null purify$ #-1 #4 substring$
  *
  sortify 'sort.label :=
}









FUNCTION {sort.format.names}
{ 's :=
  #1 'nameptr :=
  ""
  s num.names$ 'numnames :=
  numnames 'namesleft :=
    { namesleft #0 > }
    { nameptr #1 >
        { "   " * }
        'skip$
      if$

      s nameptr "{vv{ } }{ll{ }}{  ff{ }}{  jj{ }}" format.name$ 't :=

      nameptr numnames = t "others" = and
        { "et al" * }
        { t sortify * }
      if$
      nameptr #1 + 'nameptr :=
      namesleft #1 - 'namesleft :=
    }
  while$
}


FUNCTION {sort.format.title}
{ 't :=
  "A " #2
    "An " #3
      "The " #4 t chop.word
    chop.word
  chop.word
  sortify
  #1 global.max$ substring$
}


FUNCTION {author.sort}
{ author empty$
    { key empty$
        { "to sort, need author or key in " cite$ * warning$
          ""
        }
        { key sortify }
      if$
    }
    { author sort.format.names }
  if$
}

FUNCTION {author.editor.sort}
{ author empty$
    { editor empty$
        { key empty$
            { "to sort, need author, editor, or key in " cite$ * warning$
              ""
            }
            { key sortify }
          if$
        }
        { editor sort.format.names }
      if$
    }
    { author sort.format.names }
  if$
}

FUNCTION {author.organization.sort}
{ author empty$
    { organization empty$
        { key empty$
            { "to sort, need author, organization, or key in " cite$ * warning$
              ""
            }
            { key sortify }
          if$
        }
        { "The " #4 organization chop.word sortify }
      if$
    }
    { author sort.format.names }
  if$
}

FUNCTION {editor.organization.sort}
{ editor empty$
    { organization empty$
        { key empty$
            { "to sort, need editor, organization, or key in " cite$ * warning$
              ""
            }
            { key sortify }
          if$
        }
        { "The " #4 organization chop.word sortify }
      if$
    }
    { editor sort.format.names }
  if$
}


FUNCTION {presort}

{ calc.label
  sort.label
  "    "
  *
  type$ "book" =

  type$ "inbook" =
  or
    'author.editor.sort
    { type$ "proceedings" =
        'editor.organization.sort
        { type$ "manual" =
            'author.organization.sort
            'author.sort
          if$
        }
      if$
    }
  if$

  *

  "    "
  *
  year field.or.null sortify
  *
  "    "
  *
  title field.or.null
  sort.format.title
  *
  #1 entry.max$ substring$
  'sort.key$ :=
}

ITERATE {presort}


SORT








STRINGS { longest.label last.sort.label next.extra }

INTEGERS { longest.label.width last.extra.num }

FUNCTION {initialize.longest.label}
{ "" 'longest.label :=
  #0 int.to.chr$ 'last.sort.label :=
  "" 'next.extra :=
  #0 'longest.label.width :=
  #0 'last.extra.num :=
}

FUNCTION {forward.pass}
{ last.sort.label sort.label =
    { last.extra.num #1 + 'last.extra.num :=

      last.extra.num "z" chr.to.int$ >

	% Generate -1, -2, ... suffixes
	{ "-" last.extra.num "a" chr.to.int$ - #1 + int.to.str$ * 'extra.label := }
	% Generate a, b, ..., z suffixes
        { last.extra.num int.to.chr$ 'extra.label := }
      if$
    }
    { "a" chr.to.int$ 'last.extra.num :=
      "" 'extra.label :=
      sort.label 'last.sort.label :=
    }
  if$
}

FUNCTION {reverse.pass}
{

  next.extra "b" =
    { "a" 'extra.label := }
    'skip$
  if$

  label extra.label * 'label :=
  label width$ longest.label.width >
    { label 'longest.label :=
      label width$ 'longest.label.width :=
    }
    'skip$
  if$
  extra.label 'next.extra :=
}

EXECUTE {initialize.longest.label}

ITERATE {forward.pass}

REVERSE {reverse.pass}






FUNCTION {begin.bib}

{ et.al.char.used
    { "\newcommand{\etalchar}[1]{$^{#1}$}" write$ newline$ }
    'skip$
  if$
  preamble$ empty$

    'skip$
    { preamble$ write$ newline$ }
  if$
  %%% "\begin{thebibliography}{"  longest.label  * "}" * write$ newline$
  "\begin{thebibliography}{"  longest.label  * "AA}" * write$ newline$

  "\ifx \showCODEN  \undefined \def \showCODEN #1{CODEN #1}  \fi" write$ newline$


  "\ifx \showISBN   \undefined \def \showISBN  #1{{\footnotesize ISBN}: #1}   \fi" write$ newline$


  "\ifx \showISSN   \undefined \def \showISSN  #1{{\footnotesize ISSN}: #1}   \fi" write$ newline$


  "\ifx \showLCCN   \undefined \def \showLCCN  #1{LCCN #1}   \fi" write$ newline$


  "\ifx \showPRICE  \undefined \def \showPRICE #1{#1}        \fi" write$ newline$


  "\ifx \showURL    \undefined \def \showURL {URL }          \fi" write$ newline$
  "\ifx \path       \undefined \input path.sty               \fi" write$ newline$
  "\ifx \ifshowURL \undefined" write$ newline$
  "     \newif \ifshowURL"     write$ newline$
  "     \showURLtrue"          write$ newline$
  "\fi" write$ newline$

}

EXECUTE {begin.bib}

EXECUTE {init.state.consts}


ITERATE {call.type$}


FUNCTION {end.bib}
{ newline$
  "\end{thebibliography}" write$ newline$
}

EXECUTE {end.bib}
